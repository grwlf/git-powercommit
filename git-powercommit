#!/bin/sh

errexit() {
  echo "$@" >&2
  exit 1
}

which git 2>&1 >/dev/null || \
  errexit "\`git\` is not installed"

ME=`basename $0`
BNAME=powercommit
RECURSIVE=`echo "$@" | grep -q -E '\-\-no-recursive' && echo n || echo y`
DRYRUN=`echo "$@" | grep -q -E '\-\-dry-run' && echo y || echo n`
SHOWHELP=`echo "$@" | grep -q -E '\-h|--help' && echo y || echo n`
DEBUG=`echo "$@" | grep -q -E '\--debug' && echo y || echo n`
NODEBUG=`echo "$@" | grep -q -E '\--no-debug' && echo y || echo n`

if test "$SHOWHELP" = "y" ; then
  echo "Usage: $ME [-h|--help] [--debug] [--dry-run] [--no-recursive]" >&2
  exit 1
fi

if test -z "$INDENT" ; then
  INDENT=""
fi

setmode() {
  if test "$NODEBUG" = "y" ; then
    set -e +x
  else
    test "$DEBUG" = "y" && set -e -x || set -e
  fi
}

run() {
  if test "$DRYRUN" = "y" ; then
    echo "${INDENT}dry-run: $@"
  else
    "$@"
  fi
}

dirname2() {
  # Print the dirname of a file if it is not empty. Otherwize print the file.
  local dn=$(dirname "$1")
  if test "$dn" = "." ; then
    echo "$1"
  else
    echo "$dn"
  fi
}

mapchanges() {(
  # Scan git repo, call a `filter` to calculate the paths of interest. After
  # that sort these paths and call `commiter` for every such path.
  #
  # FIXME: currently ignores failures in filter or commiter, if any.
  setmode
  local filter="$1"
  local commiter="$2"
  git status --no-renames --porcelain=v2 | \
  while read N XY sub mH mI mW hH hI path ; do
    # echo "||| $N $XY $sub $mH $mI $mW $hH $hI $path" >&2
    $filter $N $XY $sub $mH $mI $mW $hH $hI "$path"
  done | \
  sort -u --reverse | \
  while read path; do
    $commiter "$path"
  done
)}

filter_normal() {
  # Inputs are according to `git status --porcelain=v2` spec. The function
  # filters normal changes, i.e. not renames and submodules
  local XY="$2"
  local subm="$3"
  shift 8; local path="$1"
  case "$XY" in
    .M|M.|MM)
      case "$subm" in
        N...) dirname2 "$path" ;;
        *) ;;
      esac ;;
    *) ;;
  esac
}

commit_normal() {
  # Commit changes assuming that the path points to normal file/folder
  local path="$1"
  run git add -u -- "$path"
  run git commit -m "Update $path"
}

filter_subm() {
  # Inputs are according to `git status --porcelain=v2` spec. The function
  # filters submodules which has changed commits.
  local sub="$3"; shift 8; local path="$1"
  case "$sub" in
    SC??) echo "$path" ;;
    *) ;;
  esac
}

commit_subm() {
  # Commit changes assuming that the path points to a submodule
  local path="$1"
  run git add -u -- "$path"
  run git commit -m "Bump $path"
}

{ git branch -a; git stash list; } | grep -q "$BNAME" && \
  errexit "Looks like the last call to powercommit failed." \
          "Consider making some investigation, then remove the branch" \
          "\`$BANME\` and the stash of the same name. Typical repair " \
          "commands are:" $'\n\n\t' \
          "git reset --hard \"$BNAME\"; git stash pop;" \
          "git branch -D \"$BNAME\""

setmode
cd -P $(git rev-parse --show-toplevel)
git status --porcelain | grep -v '^??' | grep -q '^[^\s]*' || exit 0
run git branch "$BNAME"
run git stash push -m "$BNAME"
run git pull --rebase
run git stash apply
if test "$RECURSIVE" = "y" ; then
  for s in `git submodule status | awk '{print $2}'` ; do
    echo "Entering \"$s\""
    ( cd -P "$s" && INDENT="$INDENT  " $0 "$@" ; )
    echo "Exiting \"$s\""
  done
  mapchanges filter_subm commit_subm
fi

mapchanges filter_normal commit_normal

run git push
run git branch --delete "$BNAME"
run git stash drop


