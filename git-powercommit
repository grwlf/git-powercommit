#!/bin/sh

if test -z "$GPC_WORKER" ; then
  export CLR_RED=`tput setaf 1`
  export CLR_GREEN=`tput setaf 2`
  export CLR_BLUE=`tput setaf 4`
  export CLR_RESET=`tput sgr0`
fi

msg() {
  if test "$LOGFILE" != '-' ; then
    echo "$@"
  fi
  echo "$@" >&2
}

clrmsg() {
  clr="$1" ; shift
  if test "$LOGFILE" != '-' ; then
    echo "${clr}$@${CLR_RESET}"
  fi
  echo "$@" >&2
}

monmsg() {
  if test -z "$GPC_WORKER" ; then
    clrmsg "$CLR_BLUE" "$@"
  fi
}

errexit() {
  clrmsg "$CLR_RED" "$@"
  exit 1
}

which git 2>&1 >/dev/null || \
  errexit "\`git\` is not installed"

ME=`basename $0`
BNAME=powercommit
DRYRUN=n
DEBUG=n
NODEBUG=n
RECURSIVE=y
opts=$(getopt -o ':h' -l "no-recursive,dry-run,help,debug,no-debug,log:" -- "$@")
if test "$?" != "0" ; then
  echo "Invalid options passed" >&2
  SHOWHELP=y
else
  opts_bak="$@"
  eval set -- "$opts"
  while test -n "$1"; do
    case "$1" in
      --) ;;
      --log) LOGFILE="$2" ; shift ;;
      --dry-run) DRYRUN=y ;;
      --debug) DEBUG=y ;;
      --no-debug) NODEBUG=y ;;
      --no-recursive) RECURSIVE=n ;;
      *) echo "Unknown option $1" >&2; SHOWHELP=y ;;
    esac
    shift
  done
  eval set -- "$opts_bak"
fi

if test "$SHOWHELP" = "y" ; then
  echo "Usage: $ME [-h|--help] [--debug] [--dry-run] [--no-recursive] [--log=-|FILE]" >&2
  exit 1
fi

if test -n "$LOGFILE" ; then
  if test "$LOGFILE" != "-" ; then
    exec 2>>"$LOGFILE"
    monmsg "Logging to \"$LOGFILE\""
  else
    monmsg "Logging to stdout"
  fi
else
  LOGDIR=`test -d "$TMPDIR" && echo $TMPDIR || echo /tmp`
  LOGFILE="$LOGDIR/git_powercommit_$UID.log"
  exec 2>>"$LOGFILE"
  monmsg "Logging to \"$LOGFILE\""
fi

if test -z "$GPC_INDENT" ; then
  GPC_INDENT=""
fi

setmode() {
  if test "$NODEBUG" = "y" ; then
    set -e +x
  else
    test "$DEBUG" = "y" && set -e -x || set -e
  fi
}

run() {
  if test "$DRYRUN" = "y" ; then
    echo "${GPC_INDENT}dry-run: $@"
  else
    "$@" 1>&2
  fi
}

dirname2() {
  # Print the dirname of a file if it is not empty. Otherwize print the file.
  local dn=$(dirname "$1")
  if test "$dn" = "." ; then
    echo "$1"
  else
    echo "$dn"
  fi
}

mapchanges() {(
  # Scan git repo, call a `filter` to calculate the paths of interest. After
  # that sort these paths and call `commiter` for every such path.
  setmode
  local filter="$1"
  local commiter="$2"
  export FAILPATH=`mktemp git-powercommit-$$-XXXXX`
  git status --no-renames --porcelain=v2 | \
  while read N XY sub mH mI mW hH hI path ; do
    # echo "||| $N $XY $sub $mH $mI $mW $hH $hI $path" >&2
    $filter $N $XY $sub $mH $mI $mW $hH $hI "$path"
  done | \
  sort -u --reverse | \
  while read path; do
    $commiter "$path" || echo "$path" >> "$FAILPATH"
  done
  if test -s "$FAILPATH" ; then
    rm "$FAILPATH";
    exit 1
  fi
  rm "$FAILPATH";
)}

filter_normal() {
  # Inputs are according to `git status --porcelain=v2` spec. The function
  # filters normal changes, i.e. not renames and submodules
  local XY="$2"
  local subm="$3"
  shift 8; local path="$1"
  case "$XY" in
    .M|M.|MM)
      case "$subm" in
        N...) dirname2 "$path" ;;
        *) ;;
      esac ;;
    *) ;;
  esac
}

commit_normal() {
  # Commit changes assuming that the path points to normal file/folder
  local path="$1"
  msg "Committing \"$path\""
  run git add -u -- "$path"
  run git commit -m "Update $path"
}

filter_subm() {
  # Inputs are according to `git status --porcelain=v2` spec. The function
  # filters submodules which has changed commits.
  local sub="$3"; shift 8; local path="$1"
  case "$sub" in
    SC??) echo "$path" ;;
    *) ;;
  esac
}

commit_subm() {
  # Commit changes assuming that the path points to a submodule
  local path="$1"
  msg "Committing submodule \"$path\""
  run git add -u -- "$path"
  run git commit -m "Bump $path"
}

if test -z "$GPC_WORKER" ; then
  monmsg $(date)
  GPC_WORKER=y "$0" "$@"
  ret="$?"
  if test "$ret" = "0" ; then
    exit 0
  else
    errexit "Abnormal termination"
  fi
fi

{ git branch -a; git stash list; } | grep -q "$BNAME" && \
  errexit "Looks like the last call to powercommit failed." \
          "Consider making some investigation, then remove the branch" \
          "\`$BNAME\` and the stash of the same name. Typical repair " \
          "commands are:" $'\n\n\t' \
          "git reset --hard \"$BNAME\"; git stash pop;" \
          "git branch -D \"$BNAME\"" $'\n'

setmode
RROOT=$(git rev-parse --show-toplevel)
cd -P "$RROOT"
msg "Checking the status of \"$RROOT\""
git status --porcelain | grep -v '^??' | grep -q '^[^\s]*' || exit 0
run git branch "$BNAME"
run git stash push -m "$BNAME"
msg "Pulling fresh commits from the upstream"
run git pull --rebase
run git stash apply || true # Could be empty
if test "$RECURSIVE" = "y" ; then
  for s in `git submodule status | awk '{print $2}'` ; do
    clrmsg "$CLR_BLUE" "Visiting submodule \"$s\""
    ( cd -P "$s" && GPC_INDENT="$GPC_INDENT  " $0 "$@" ; )
  done
  mapchanges filter_subm commit_subm
fi

mapchanges filter_normal commit_normal

msg "Pushing the changes upstream"
run git push
run git branch --delete "$BNAME"
run git stash drop || true # Could be empty
clrmsg "$CLR_GREEN" "Done"

