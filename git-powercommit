#!/bin/sh

# TODO: Filter handlers use stdout to report results, and stderr is redirected
# to a logfile. One need to find the way for them to print messages to the
# terminal.

if test -z "$GPC_WORKER" ; then
  export CLR_RED=`tput setaf 1 || echo ""`
  export CLR_GREEN=`tput setaf 2 || echo ""`
  export CLR_BLUE=`tput setaf 4 || echo ""`
  export CLR_PINK=`tput setaf 5 || echo ""`
  export CLR_RESET=`tput sgr0 || echo ""`
fi

# Logs go to stderr, which could be redirected to a file. User messages go to
# stdout which is not normally redirected.
msg() {
  if test "$LOGFILE" != '-' ; then
    echo "$GPC_INDENT$@"
  fi
  echo "$GPC_INDENT$@" >&2
}

clrmsg() {
  clr="$1" ; shift
  if test "$LOGFILE" != '-' ; then
    echo "$GPC_INDENT${clr}$@${CLR_RESET}"
  fi
  echo "$GPC_INDENT$@" >&2
}

monmsg() {
  if test -z "$GPC_WORKER" ; then
    clrmsg "$CLR_BLUE" "$@"
  fi
}

errexit() {
  clrmsg "$CLR_RED" "$@"
  exit 1
}

BNAME=powercommit
recoverexit() {
  errexit $'\n'"Looks like the previous call to git-powercommit failed." \
          "Consider making some investigation, then remove the branch" \
          "\`$BNAME\` and the stash of the same name. Typical repair" \
          "commands are:" $'\n\n\t' \
          "git reset --hard \"$BNAME\"; git stash pop;" \
          "git branch -D \"$BNAME\"" $'\n'
}

which git 2>&1 >/dev/null || \
  errexit "\`git\` is not installed"

ME=`basename $0`
GPC="$(cd -P $(dirname $0) && pwd)/$ME"
DRYRUN=n
DEBUG=y
NODEBUG=n
RECURSIVE=y
opts=$(getopt -o ':h' -l "no-recursive,dry-run,help,debug,no-debug,log:" -- "$@")
if test "$?" != "0" ; then
  echo "Invalid options passed" >&2
  SHOWHELP=y
else
  opts_bak="$@"
  eval set -- "$opts"
  while test -n "$1"; do
    case "$1" in
      --) ;;
      --log) LOGFILE="$2" ; shift ;;
      --dry-run) DRYRUN=y ;;
      --debug) DEBUG=y ;;
      --no-debug) NODEBUG=y ;;
      --no-recursive) RECURSIVE=n ;;
      -h|--help) SHOWHELP=y ;;
      *) echo "Unknown option $1" >&2; SHOWHELP=y ;;
    esac
    shift
  done
  eval set -- "$opts_bak"
fi

if test "$SHOWHELP" = "y" ; then
  echo "Usage: $ME [-h|--help] [--debug] [--dry-run] [--no-recursive] [--log=-|FILE]" >&2
  exit 1
fi

if test -n "$LOGFILE" ; then
  if test "$LOGFILE" != "-" ; then
    exec 2>>"$LOGFILE"
    monmsg "Logging to \"$LOGFILE\""
  else
    monmsg "Logging to stdout"
  fi
else
  LOGDIR=`test -d "$TMPDIR" && echo $TMPDIR || echo /tmp`
  LOGFILE="$LOGDIR/git_powercommit_$UID.log"
  exec 2>>"$LOGFILE"
  monmsg "Logging to \"$LOGFILE\""
fi

echo "Opts: $@" >&2

if test -z "$GPC_INDENT" ; then
  GPC_INDENT=""
fi

setmode() {
  if test "$NODEBUG" = "y" ; then
    set -e +x
  else
    test "$DEBUG" = "y" && set -e -x || set -e
  fi
}

run() {
  if test "$DRYRUN" = "y" ; then
    echo "${GPC_INDENT}dry-run: $@"
  else
    "$@" 1>&2
  fi
}

dirname2() {
  # Print the dirname of a file if it is not empty. Otherwize print the file.
  local dn=$(dirname "$1")
  if test "$dn" = "." ; then
    echo "$1"
  else
    echo "$dn"
  fi
}

mapchanges() {(
  # Scan git repo, call `filter` to calculate the paths of interest. After
  # that sort these paths and call `commiter` for every such path.
  setmode
  local filter="$1"
  local commiter="$2"
  export FAILPATH=`mktemp -t git-powercommit-$$-XXXXX`
  git status --no-renames --porcelain=v2 | \
  while read N XY sub mH mI mW hH hI path ; do
    echo "porcelain: $N $XY $sub $mH $mI $mW $hH $hI $path" >&2
    $filter $N $XY $sub $mH $mI $mW $hH $hI "$path"
  done | \
  sort -u --reverse | \
  while read path; do
    $commiter "$path" || echo "$path" >> "$FAILPATH"
  done
  if test -s "$FAILPATH" ; then
    rm "$FAILPATH";
    exit 1
  fi
  rm "$FAILPATH";
)}

filter_normal() {
  # Inputs are according to `git status --porcelain=v2` spec. The function
  # filters normal changes, i.e. not renames and submodules
  local N="$1"
  case "$N" in
    1)
      local XY="$2"
      local subm="$3"
      shift 8; local path="$1"
      case "$XY" in
        # Modified
        .M|M.|MM)
          case "$subm" in
            # Not a submodule
            N...) dirname2 "$path" ;;
            *) ;;
          esac ;;
        *) ;;
      esac ;;
    *) ;;
  esac
}

commit_normal() {
  # Commit changes assuming that the path points to normal file/folder
  local path="$1"
  msg "Committing \"$path\""
  run git add -u -- "$path"
  run git commit -m "Update $path"
}

filter_untracked() {
  local N="$1"
  case "$N" in
    \?)
      shift 1; local path="$1"
      echo "$path" ;;
    *) ;;
  esac
}

commit_untracked() {
  local path="$1"
  if test -f "$GPC_UNTRACKED"; then
    echo $path >> "$GPC_UNTRACKED"
  fi
}

filter_subm() {
  # Inputs are according to `git status --porcelain=v2` spec. The function
  # filters submodules which has changed commits.
  local sub="$3"; shift 8; local path="$1"
  case "$sub" in
    SC??) echo "$path" ;;
    *) ;;
  esac
}

commit_subm() {
  # Commit changes assuming that the path points to a submodule
  local path="$1"
  msg "Committing submodule \"$path\""
  run git add -u -- "$path"
  run git commit -m "Bump $path"
}

if test -z "$GPC_WORKER" ; then
  # Top-level part re-runs itself as a worker.
  { echo; echo
    echo "============================================================"
    echo "Starting git-powercommit, $(LANG=C date)"
    echo "============================================================"
  } >&2
  UNTRACKED=$(mktemp -t git_powercommit_$$_XXXXX.txt)
  trap "recoverexit" SIGINT
  GPC_WORKER=y \
  GPC_UNTRACKED=$UNTRACKED \
    "$GPC" "$@"
  ret="$?"
  if test "$ret" != "0" ; then
    errexit "Abnormal termination"
  fi
  setmode
  n=0
  for path in $(cat $UNTRACKED); do
    desc=$(LANG=C file $path | awk -F ': ' '{print $2}')
    if echo "$desc" | grep -q -i -E 'source|text|script' ; then
      clrmsg "$CLR_PINK" "Untracked $path: $desc"
    fi
    n=$(expr "$n" + 1)
  done
  msg "$n untracked files"
  rm "$UNTRACKED"
  clrmsg "$CLR_GREEN" "Done"
else
  # Worker part.
  { git branch -a; git stash list; } | grep -q "$BNAME" && \
    recoverexit

  if test "$RECURSIVE" = "y" ; then
    for s in `git submodule status | awk '{print $2}'` ; do
      ( cd -P "$s" && \
        git status --porcelain | grep -v '^??' | grep -q '^[^\s]*' || exit 0 && \
        git symbolic-ref -q HEAD >/dev/null ; ) || \
        errexit "Submodule \"$s\" is in the detached HEAD state so \"git" \
          "push\" will fail. Please checkout it to the correct branch:" $'\n\n\t' \
          "git branch -f branch HEAD && git checkout master" $'\n\n' \
          "Consider using \`git submodule update --rebase\` or \`... --merge\`" \
          "in future." $'\n'
    done
  fi

  setmode
  RROOT=$(git rev-parse --show-toplevel)
  cd -P "$RROOT"
  msg "Checking the status of \"$RROOT\""
  git status --porcelain | grep -v '^??' | grep -q '^[^\s]*' || exit 0
  run git branch "$BNAME"
  run git stash push -m "$BNAME"
  msg "Pulling fresh commits from the upstream"
  run git pull --rebase
  run git stash apply || true # Could be empty
  if test "$RECURSIVE" = "y" ; then
    for s in `git submodule status | awk '{print $2}'` ; do
      clrmsg "$CLR_BLUE" "Visiting submodule \"$s\""
      ( cd -P "$s" && GPC_INDENT="$GPC_INDENT  " $GPC "$@" ; )
    done
    mapchanges filter_subm commit_subm
  fi

  clrmsg "$CLR_BLUE" "Commiting local changes"
  mapchanges filter_untracked commit_untracked
  mapchanges filter_normal commit_normal

  msg "Pushing the changes upstream"
  run git push
  run git branch --delete "$BNAME"
  run git stash drop || true # Could be empty
fi

