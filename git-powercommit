#!/bin/sh

errexit() {
  echo "$@" >&2
  exit 1
}

msg() {
  echo "$@" >&2
}

which git 2>&1 >/dev/null || \
  errexit "\`git\` is not installed"

ME=`basename $0`
BNAME=powercommit
DRYRUN=n
DEBUG=n
NODEBUG=n
opts=$(getopt -o ':h' -l "no-recursive,dry-run,help,debug,log:" -- "$@")
if test "$?" != "0" ; then
  echo "Invalid options passed" >&2
  SHOWHELP=y
else
  opts_bak="$@"
  eval set -- "$opts"
  while test -n "$1"; do
    case "$1" in
      --) ;;
      --log) LOGFILE="$2" ; shift ;;
      --dry-run) DRYRUN=y ;;
      --debug) DEBUG=y ;;
      --no-debug) NODEBUG=y ;;
      *) echo "Unknown option $1" >&2; SHOWHELP=y ;;
    esac
    shift
  done
  eval set -- "$opts_bak"
fi

if test "$SHOWHELP" = "y" ; then
  echo "Usage: $ME [-h|--help] [--debug] [--dry-run] [--no-recursive] [--log=-|FILE]" >&2
  exit 1
fi

if test -n "$LOGFILE" ; then
  if test "$LOGFILE" != "-" ; then
    msg "Logging to \"$LOGFILE\""
    exec >>"$LOGFILE"
  else
    msg "Logging to stdout"
  fi
else
  LOGDIR=`test -d "$TMPDIR" && echo $TMPDIR || echo /tmp`
  LOGFILE="$LOGDIR/git_powercommit_$UID.log"
  msg "Logging to \"$LOGFILE\""
  exec >>"$LOGFILE"
fi

if test -z "$INDENT" ; then
  INDENT=""
fi

setmode() {
  if test "$NODEBUG" = "y" ; then
    set -e +x
  else
    test "$DEBUG" = "y" && set -e -x || set -e
  fi
}

run() {
  if test "$DRYRUN" = "y" ; then
    echo "${INDENT}dry-run: $@"
  else
    "$@" 2>&1
  fi
}

dirname2() {
  # Print the dirname of a file if it is not empty. Otherwize print the file.
  local dn=$(dirname "$1")
  if test "$dn" = "." ; then
    echo "$1"
  else
    echo "$dn"
  fi
}

mapchanges() {(
  # Scan git repo, call a `filter` to calculate the paths of interest. After
  # that sort these paths and call `commiter` for every such path.
  #
  # FIXME: currently ignores failures in filter or commiter, if any.
  setmode
  local filter="$1"
  local commiter="$2"
  git status --no-renames --porcelain=v2 | \
  while read N XY sub mH mI mW hH hI path ; do
    # echo "||| $N $XY $sub $mH $mI $mW $hH $hI $path" >&2
    $filter $N $XY $sub $mH $mI $mW $hH $hI "$path"
  done | \
  sort -u --reverse | \
  while read path; do
    $commiter "$path"
  done
)}

filter_normal() {
  # Inputs are according to `git status --porcelain=v2` spec. The function
  # filters normal changes, i.e. not renames and submodules
  local XY="$2"
  local subm="$3"
  shift 8; local path="$1"
  case "$XY" in
    .M|M.|MM)
      case "$subm" in
        N...) dirname2 "$path" ;;
        *) ;;
      esac ;;
    *) ;;
  esac
}

commit_normal() {
  # Commit changes assuming that the path points to normal file/folder
  local path="$1"
  msg "Committing \"$path\""
  run git add -u -- "$path"
  run git commit -m "Update $path"
}

filter_subm() {
  # Inputs are according to `git status --porcelain=v2` spec. The function
  # filters submodules which has changed commits.
  local sub="$3"; shift 8; local path="$1"
  case "$sub" in
    SC??) echo "$path" ;;
    *) ;;
  esac
}

commit_subm() {
  # Commit changes assuming that the path points to a submodule
  local path="$1"
  msg "Committing submodule \"$path\""
  run git add -u -- "$path"
  run git commit -m "Bump $path"
}

{ git branch -a; git stash list; } | grep -q "$BNAME" && \
  errexit "Looks like the last call to powercommit failed." \
          "Consider making some investigation, then remove the branch" \
          "\`$BANME\` and the stash of the same name. Typical repair " \
          "commands are:" $'\n\n\t' \
          "git reset --hard \"$BNAME\"; git stash pop;" \
          "git branch -D \"$BNAME\""

setmode
cd -P $(git rev-parse --show-toplevel)
msg "Checking uncommitted changes"
git status --porcelain | grep -v '^??' | grep -q '^[^\s]*' || exit 0
run git branch "$BNAME"
run git stash push -m "$BNAME"
msg "Pulling fresh commits from the upstream"
run git pull --rebase
run git stash apply
if test "$RECURSIVE" = "y" ; then
  for s in `git submodule status | awk '{print $2}'` ; do
    msg "Visiting submodule \"$s\""
    ( cd -P "$s" && INDENT="$INDENT  " $0 "$@" ; )
  done
  mapchanges filter_subm commit_subm
fi

mapchanges filter_normal commit_normal

msg "Pushing the changes upstream"
run git push
run git branch --delete "$BNAME"
run git stash drop
msg "Done"

